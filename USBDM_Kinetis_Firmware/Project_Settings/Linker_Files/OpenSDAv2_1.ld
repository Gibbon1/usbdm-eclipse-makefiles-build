/* MK, MKL, MKE version
 * Linker script based on example scripts provided with ARM Ltd GCC
 *
 * It references the following symbols, which must be defined in code:
 * 
 *      Reset_Handler : Entry of reset handler
 * 
 * 
 * It defines the following symbols, which code can use without definition:
 *      __exidx_start
 *      __exidx_end
 *      __etext
 *      __data_start__
 *      __preinit_array_start
 *      __preinit_array_end
 *      __init_array_start
 *      __init_array_end
 *      __fini_array_start
 *      __fini_array_end
 *      __data_end__
 *      __bss_start__
 *      __bss_end__
 *      __end__
 *      end
 *      __HeapBottom
 *      __HeapLimit
 *      __StackLimit
 *      __StackTop
 *      __stack
 */
 
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
SEARCH_DIR(.)

/* <o> Stack Size
   <i> Required amount of stack space  
   <0x0-0x4000> 
*/
__stack_size = 0x1000;

/* <o> GDB stack fix 
   <i> A small amount of reserve RAM used to prevent an Eclipse GDB bug that occurs when the stack is near unallocated memory
   <0-32> 
*/
__gdbstack_fix = 8;

/* <o> Minimum Heap Size 
   <i> Actual heap may be larger as it fills all unused RAM 
   <0x0-0x4000> 
*/
__heap_size  = 0x1000;

/* <h>RAM region used for stack and heap   <o0>  start <o1> length  </h> */
/* <h>Flash region used for code, data etc.<o2>  start <o3> length  </h> */
/*
 * Memory Map generated by USBDM New Project Wizard for MK20DX128M5
 */
MEMORY
{
  ram        (rwx) : ORIGIN = 0x1FFFE000, LENGTH = 0x00004000
  rom        (rx)  : ORIGIN = 0x00008000, LENGTH = 0x00020000-0x8000
  flexNVM    (rx)  : ORIGIN = 0x10000000, LENGTH = 0x00008000
  io         (rwx) : ORIGIN = 0x22000000, LENGTH = 0x02000000
  io_1       (rwx) : ORIGIN = 0x40000000, LENGTH = 0x00080000
  io_2       (rwx) : ORIGIN = 0x40080000, LENGTH = 0x0007F000
  io_3       (rwx) : ORIGIN = 0x400FF000, LENGTH = 0x00001000
  io_4       (rwx) : ORIGIN = 0x42000000, LENGTH = 0x02000000
  io_5       (rwx) : ORIGIN = 0x44000000, LENGTH = 0x1C000000
  io_6       (rwx) : ORIGIN = 0xE0000000, LENGTH = 0x00100000
};

ENTRY(Reset_Handler)

PROVIDE(__HardReset = Reset_Handler);
PROVIDE(__gdbstack_fix = 0);

SECTIONS
{
	.text :
	{
		 __flash_start = .;
		
		/* Vector table */
		KEEP(*(.interrupt_vectors))
		/* Make sure we pulled in at least a reset vector.  */
		ASSERT (. != __flash_start, "No interrupt vector");
	
		/* Emit a Security field */
		. = __flash_start + 0x400;
		KEEP(*(.security_information))
		ASSERT (. == __flash_start + 0x410, "No security information");

		*(.text*)
	
		KEEP(*(.init))
		KEEP(*(.fini))
	
		/* .ctors */
		*crtbegin.o(.ctors)
		*crtbegin?.o(.ctors)
		*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
		*(SORT(.ctors.*))
		*(.ctors)
	
		/* .dtors */
		*crtbegin.o(.dtors)
		*crtbegin?.o(.dtors)
		*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
		*(SORT(.dtors.*))
		*(.dtors)
	
		. = ALIGN(4);
		/* preinit data */
		PROVIDE_HIDDEN (__preinit_array_start = .);
		KEEP(*(.preinit_array))
		PROVIDE_HIDDEN (__preinit_array_end = .);

		. = ALIGN(4);
		/* init data */
		PROVIDE_HIDDEN (__init_array_start = .);
		KEEP(*(SORT(.init_array.*)))
		KEEP(*(.init_array))
		PROVIDE_HIDDEN (__init_array_end = .);

		. = ALIGN(4);
		/* finit data */
		PROVIDE_HIDDEN (__fini_array_start = .);
		KEEP(*(SORT(.fini_array.*)))
		KEEP(*(.fini_array))
		PROVIDE_HIDDEN (__fini_array_end = .);

		KEEP(*(.jcr*))

		*(.rodata*)
	
		KEEP(*(.eh_frame*))
	} > rom

	.ARM.extab : 
	{
		*(.ARM.extab* .gnu.linkonce.armextab.*)
	} > rom

	__exidx_start = .;
	.ARM.exidx :
	{
		*(.ARM.exidx* .gnu.linkonce.armexidx.*)
	} > rom
	__exidx_end = .;

	__etext = .;
		
	.data : AT (__etext)
	{
		__data_start__ = .;
		*(vtable)
		*(.data*)

		. = ALIGN(4);
		/* All data end */
		__data_end__ = .;

	} > ram

	.bss :
	{
		. = ALIGN(4);
		__bss_start__ = .;
		*(.bss*)
		*(COMMON)
		. = ALIGN(4);
		__bss_end__ = .;
	} > ram
	
   /* Minimum HEAP - from top of BSS */
  .heap_dummy :
  {
    . = ALIGN(4);
    PROVIDE ( end = . );
    PROVIDE ( __end__ = . );
    PROVIDE ( _end = . );
   __HeapBottom = .;
	__heap_addr = .;
    . = . + __heap_size;
  } > ram

   /* Dummy STACK space - between HEAP and end of RAM*/
  .stack_dummy :
  {
    . = ALIGN(4);
    . = . + __stack_size;
  } > ram

  /* Set stack top to end of ram, and stack limit move down by
   * size of stack_dummy section 
   */
  __StackTop   = ORIGIN(ram) + LENGTH(ram) - __gdbstack_fix; /* subtract fix for GDB bug */
  __HeapLimit  = ORIGIN(ram) + LENGTH(ram) - __stack_size;
  __StackLimit = ORIGIN(ram) + LENGTH(ram) - __stack_size;
  
  PROVIDE(__stack = __StackTop);
  PROVIDE(__cs3_stack = __StackTop);
}
